# 1.代码结构介绍

## 1.1.CloudFunctions

> CloudFunctions指定腾讯云项目的目录

## 1.2.miniprogram

> 小程序端的代码

### 1.2.1.文件介绍

- images文件夹下存放的是小程序对应的默认的图片文件
- pages文件夹下存放的是与小程序界面相关的文件
  - .json：配置文件，以json格式存储一些配置（全局配置、页面配置、项目配置）
  - .wxml：模版文件，描述页面结构，相当于HTML
  - .wxss：样式文件，调整页面样式，相当于css
  - .js：脚本逻辑文件，页面和用户的交互逻辑

### 1.2.Json文件

> 更多具体配置见[微信官方文档](https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html)介绍

1. project.config.json：项目配置文件
   - 对项目进行配置
2. app.json：全局配置
   - 在miniprogram下面
   - pages配置项中的内容相当于每个页面的路由
   - window配置项对应于窗口的配置
     -  "backgroundColor": 窗口颜色
     - "backgroundTextStyle": 窗口文字样式
     - "navigationBarBackgroundColor": 导航栏颜色
     -  "navigationBarTitleText":可以用来修改导航栏文字部分
     - "navigationBarTextStyle": 可以用来修改导航栏文字的颜色
   - tabBar配置
     -  "color": 未被选中时tabBar文字的颜色
     - “selectedColor":被选中时tabBar文字的颜色
     - “list”：个数最少两个，最多五个
       -  "pagePath":这个地址一定要是pages中配置过的地址
       - "text": tabBar中显示的文字
       - "iconPath": "images/base.png"（tabBar没有被选中时显示的图片路径）
       - "selectedIconPath": "images/base-actived.png"（tabBar被选中时显示的图片路径）
3. page.json：页面配置
   - 如项目中的cloud.json中（局部样式，只对cloud界面有效）
     - "navigationBarBackgroundColor": 页面头部背景颜色
     - "navigationBarTextStyle": 页面头部字体颜色
     -  "navigationBarTitleText": 页面头部文字内容

## 1.3.页面结构WXML

> 是小程序框架设计的一套标签语言，结合小程序的基础组件、事件系统，可以构建出页面的结构。充当的就是类似html的角色。

### 1.3.1.数据绑定

> 小程序中的数据一般情况下需要动态的从服务端获取，然后再渲染输出到视图中显示。
>
> WXML中的动态数据均来自对应Page的data

数据绑定使用Mustache语法（双大括号）将变量包起来

### 1.3.2.常见组件

> 常见组件见[微信文档](https://developers.weixin.qq.com/miniprogram/dev/component/)

```xml
<view>{{msg}}</view>   //双向绑定
<image src="{{img}}"></image>
<view wx:for="{{arr}}" wx:key="{{index}}">
  {{index}} {{item}}
</view>   //对数组arr的操作，遍历数组

<view wx:for="{{list}}" wx:key="{{index}}">
  {{item.name}}-{{item.age}}
</view>
```

### 1.3.3.条件渲染

1. 使用wx:if="{{condition}}"来判断是否需要渲染该代码块，也可以使用wx:elif和x:else来添加一个else块

   ```xml
   <view wx:if="{{isLogin}}">
     jerry
   </view>
   <view wx:else>请登录</view>
   ```

2. wx:if   VS   hidden:

   hidden后面的值为true就会隐藏，为false就显示；使用wx:if不显示的内容不会出现在wxml中，使用hidden不显示的内容仍然会出现在wxml中。（如果需要频繁切换的情景下，用hidden更好；如果在运行时条件不大可能改变则wx:if 更好）

   ```xaml
   <view hidden="{{isLogin}}">
     hidden
   </view>
   ```

## 1.4.页面样式WXSS

> - WXSS是一套用于小程序的样式语言，用于描述WXML的组件样式，也就是视觉上的效果
> - 尺寸单位：rpx（可以根据屏幕宽度进行自适应，适配不同宽度的屏幕）
> - 引入外部wxss：@import ‘……’

Eg:

```css
//引入外部样式common.wxss
@import '../../style/common.wxss';

//class='box'的组件的样式
.box{
  width: 200rpx;
  height: 200rpx;
  background: #ccc;
}
```

### 1.4.1.第三方样式库

- WeUI
- iView Weapp
- Vant Weapp

## 1.5.页面交互JS

### 1.5.1.js负责逻辑交互

- 一个计数器的demo

  bindtap=‘ ’用于绑定函数/事件（事件是对用户的交互操作行为的响应），在js文件中的onTabHandler就是对应函数的具体实现。在修改data中的值时，要用setData方法进行修改

  ```xml
  <button size='mini' bindtap='onTabHandler'>点我加一</button>
  <view>{{count}}</view>
  ```

  ```javascript
  onTabHandler: function(){
      this.setData({
        count:this.data.count+1
      })
    }
  ```

### 1.5.2.bind  VS  catch

- 使用bind绑定的子元素会进行事件冒泡，即点击子元素时，子元素的事件会逐层向父元素传播，从而调用父元素的事件

- 使用catch绑定的子元素可以避免事件冒泡

- ```xml
  <view class="box" bindtap='onTabBoxHandler'>
    <view class="child" bindtap='onTabChildHandler'>
    </view>
  </view>
  
  <view class="box" catch:tap='onTabBoxHandler'>
    <view class="child" catch:tap='onTabChildHandler'>
    </view>
  </view>
  ```

### 1.5.3.事件对象

> 事件对象代表事件的状态。当组件绑定的事件被触发时，就会传递一个事件对象到绑定的函数当中。





# 2.小程序云开发

## 2.1.云开发简介

> 微信小程云开发是腾讯云和微信团队推出的全新的小程序的解决方案。它提出了云函数、云数据库、云存储三大技术能力。可以将小程序服务端的部署和运维托管给腾讯云管理

## 2.2.小程序传统开发模式

1. 客户端（相当于前端）
2. 服务端（将后端代码和数据库放到服务器上，相当于后端）
3. 客户端和服务端在写代码时需要进行沟通以统一数据的接口，沟通的成本很高，随之也提高了小程序开发的成本。
4. 运维（包括数据库运维、文件存储、内容加速、网络防护、容器服务、负载均衡、安全加固……）成本高

## 2.3.小程序云开发模式

1. 客户端（相当于前端）
2. 云开发（包括云函数<node.js>、云数据库、云存储）
3. 可以直接在客户端调用云数据库中的内容、调用云函数（可以在云函数中处理业务逻辑，也可以在云函数中调用云数据库）、通过云存储上传下载文件
4. 全部部署在腾讯云上，不需要额外的运维人员，运维成本大大降低

## 2.4.三大基础能力支持

### 2.4.1.云函数

> - 为用户提供了在云端运行代码的能力。
> - 可以很方便的获取到用户登录的信息和openid
> - 可以很方便的获取小程序的appid
> - 生成分享图
> - 调用腾讯云SDK
> - ……

- 云函数是运行在云端的代码，相当于小程序的后台代码

- 云函数在cloudfunctions文件夹下面，每次修改云函数都要重新上传并部署云函数

- 三个例子

  - 求和函数sum()

    - 在sum目录下的index.js文件作修改

      ```javascript
      // 云函数入口函数
      // event包括当前调用云函数时在小程序端对应的参数
      // context：当前调用的上下文，包括一些当前用户的信息
      exports.main = async (event, context) => {
        return{
          sum: event.a+event.b
        }
      }
      ```

    - 在cloud.wxml中添加如下代码，用于绑定事件

      ```xml
      <button bindtap='sum'>调用云函数sum</button>
      ```

    - 在cloud.js中添加如下代码

      ```javascript
      sum:function(){
          //通过wx.cloud.callFunction调用云函数
          //name代表云函数的名称
          //data代表要传递给云函数的参数
          wx.cloud.callFunction({
            name:'sum',
            data:{
              a:2,
              b:3
            }
          }).then(res=>{
            console.log(res);
          }).catch(err=>{
            console.log(err);
          });
        }
      ```

  - 获取当前用户的openid

    - 传统微信用户登录：

      - 通过用户端小程序发起请求，调用wx.login从微信服务端获取code，再通过wx.request将code传递给后端服务器，使用code从后但服务器换取openid和session-key，将openid发送给小程序本地存储

    - 云开发微信登录：

      - 用户点击按钮获取用户信息，小程序调用云函数获取用户信息。云函数可以直接返回当前用户的openid，小程序将用户信息存储到云数据库中

    -  login云函数为自带的，可以不用写。只需要在cloud.js中完成getOpenId函数即可

      ```javascript
       getOpenId:function(){
          wx.cloud.callFunction({
            name:'login'
          }).then(res=>{
            console.log(res);
          }).catch(err=>{
            console.log(err);
          });
        }
      ```

  - 批量删除云数据库的数据

    - 创建batchDelete函数，并在js文件中编写

      ```javascript
      const db=cloud.database();  //初始化数据库
      // 云函数入口函数
      // await是对js异步操作的一种方式
      exports.main = async (event, context) => {
        try{
          //删除name是jerry的记录
          return await db.collection('user').where({
             name:'jerry'
          }).remove();
        }catch(err){
          console.log(err);
        }
      }
      ```

    - 在cloud.wxml中创建按钮并绑定batchDelete事件

    - 在cloud.js完成batchDelete函数

      ```javascript
       batchDelete:function(){
          wx.cloud.callFunction({
            name:'batchDelete'
          }).then(res=>{
            console.log(res);
          }).catch(err=>{
            console.log(err);
          })
        }
      ```

### 2.4.2.云数据库

> 数据增加、删除、修改、查询

- 云开发提供了一个JSON数据库（数据库中的每一条数据都是json格式的对象）

- 不同于传统的关系型数据库（有行有列），云数据库是文档型数据库。一个文档型数据库包含了多个集合（一个集合就相当于关系型数据库中的表）、多条记录（一条就相当于关系型数据库中的一行）、多个字段（一个字段就相当于关系型数据库中的列）

- 数据库数据类型：

  - String：字符串
  - Number：数字
  - Object：对象
  - Array：数组
  - Bool：布尔值
  - GeoPoint：地理位置点（用经纬度唯一标记一个点，查询时要建立地理标志的索引）
  - Date：时间（小程序端创建的时间是客户端的时间，不是服务端的时间）
  - Null

- 操作云数据库的方式：

  - 小程序控制（读写数据库受权限控制限制）
  - 云函数控制（拥有所有读写数据库的权限）
  - 可视化控制台控制（拥有所有读写数据库的权限）

- 云数据库权限管理：

  - 仅创建者可写，所有人可读
  - 仅创建者可读写（适用于私密相册）
  - 仅管理端可写，所有人可读（适合于商品信息）
  - 尽管理端可读写

- 数据库初始化：

  ```javascript
  const db=wx.cloud.database()   //初始化
  
  //切换环境（小程序云开发提供两个环境）
  const testDB=wx.cloud.database({
    //通过环境名称切换环境
       env: 'test'
  })
  ```

- 对数据库的操作：

  首先在cloud.wxml中通过按钮绑定事件函数，再在cloud.js文件中初始化数据库并且完成事件函数的编写

  ```javascript
  // 初始化数据库，db代表云数据库
  const db=wx.cloud.database();
  
  
  // 查询操作
  // 回调函数的写法
  insert:function(){
      // 通过db.collection取到云数据库中的集合user
      // 通过add方法增加数据
      db.collection('user').add({
        data:{
          name:'jerry',
          age:20
        },
        // 当插入成功时会调用success这个回调函数的内容
        success: res=>{ //箭头函数
          console.log(res);
        },
        // 当插入失败时会调用fail这个回调函数的内容
        fail: err=>{
          console.log(err);
        }
      })
  }
  
  // promise的写法
  // 当插入成功时会进入then里面进行操作
  // 当插入失败时会进入catch里面进行操作
  insert:function(){
    db.collection('user').add({
        data:{
          name:'jack',
          age:18
        }
      }).then(res=>{
        console.log(res);
      }).catch(err=>{
        console.log(err);
      })
  }
  
  
  //更新操作，一定要通过云数据库中对应的id进行更新
  //通过doc函数和id号的到要更新的数据
  update:function(){
      db.collection('user').doc
      ('cbddf0af606d6fd700c914e2447ac166').update({
        data:{
          age: 21
        }
      }).then(res=>{
        console.log(res)
      }).catch(err=>{
        console.log(err)
      })
  }
  
  //查找操作，通过where函数进行查找，查找时要注意查找权限的问题
  search:function(){
      db.collection('user').where({
        name:'jerry'
      }).get().then(res=>{ 
        console.log(res);
      }).catch(err=>{
        console.log(err);
      })
  }
  
  //删除操作，删除操作也需要知道要删除数据的id，调用doc函数和remove函数
  //单条数据的删除
  delete:function(){
      db.collection('user')
      .doc('cbddf0af606d6fd700c914e2447ac166')
      .remove()
      .then(res=>{
        console.log(res);
      }).catch(err=>{
        console.log(err);
      })
  }
  
  //数据批量删除需要在云函数中进行操作
  ```

### 2.4.3.云存储

> 管理、上传、下载、分享文件

- 相关命令

  ```javascript
  wx.cloud.uploadFile  //上传文件
  wx.cloud.downloadFile. //下载文件
  wx.cloud.deleteFile    //删除文件
  wx.cloud.getTempalteFileURL    //获取临时链接
  ```

- 文件上传

  - 用户选择图片或拍照上传小程序，小程序上传所选图片到云存储，云存储返回图片对应的fileID给小程序（通过fileID可以找到该图片），小程序再将fieldID存到云数据库中，方便进行后续操作

  - 上传图片

    ```javascript
    upload:function(){
        //选择本地的图片
        wx.chooseImage({
          //count表示当前选择图片的个数
          count: 1,
          //当前是以原文件的形式上传还是以压缩的形式上传
          sizeType: ['original', 'compressed'],
          //当前文件的来源
          sourceType: ['album', 'camera'],
          //回调函数，获取到当前选择图片的临时路径
          success (res) {
            // tempFilePath可以作为img标签的src属性显示图片
            // tempFilePath就是当前选择图片的临时路径，可以通过该路径将图片上传到对应的云存储中
            // tempFilePaths是一个数组
            const tempFilePaths = res.tempFilePaths
            wx.cloud.uploadFile({
              cloudPath: 'new Date().getTime() +'.png'',  //上传至云端的路径（文件名称），注意要每一个都不一样
              filePath: tempFilePaths[0], // 小程序临时文件路径
            }).then(res => {
              // 返回文件ID
              console.log(res.fileID)
            //将filedID存储到云数据库中
              db.collection('image').add({
                data:{
                  fileID:res.fileID
                }
              }).then(res=>{
                console.log(res);
              }).catch(err=>{
                console.log(err);
              })
            }).catch(error => {
              // handle error
              console.log(error)
            })
          }
        })
      }
    ```

  - 将选择的图片展示

    - 首先在page的data区域中新建一个images列表，用于存放图片的路径

    - ```xml
      <block wx:for="{{images}}">
         <image src="{{item.fileID}}"></image>
      </block>
      //在wxml文件中遍历images列表，并展示图片
      ```

    - 根据当前用户的openid获得该用户上传的图片文件的fileID，并赋值给images列表

      ```javascript
       getFile:function(){
          //获取当前用户的openid
          wx.cloud.callFunction({
            name:'login'
          }).then(res=>{
            //查询匹配的数据
            db.collection('image').where({
              _openid: res.result.openid
            }).get().then(res2=>{
              console.log(res2);
              //将fileID赋值给images列表
              this.setData({
                images:res2.data
              })
            })
          })
       }
      ```

- 文件下载

  - 首先通过微信小程序去云存储中获取文件的fileID，用户点击下载按钮后，小程序发送文件下载请求到云数据库。云数据库返回对应文件信息给小程序，小程序就可以下载文件到手机相册

  - 下载图片并存到手机相册

    ```xml
    <block wx:for="{{images}}">
       <image src="{{item.fileID}}"></image>
       <button data-fileid="{{item.fileID}}" size="mini" bindtap='downloadFile'>文件下载</button>
    </block>
    ```

    ```javascript
    downloadFile:function(event){
      //微信小程序api
        wx.cloud.downloadFile({
          //要下载的当前文件的fileID
          fileID: event.target.dataset.fileid  //cloud.wxml中自定义的属性 文件的fileid
        }).then(res => {
          // 临时文件路径
          console.log(res.tempFilePath)
          //保存图片到手机相册 微信小程序api
          wx.saveImageToPhotosAlbum({
             // 临时文件路径
            filePath: res.tempFilePath,
            success(res) {
              //小程序的轻提示组件
              wx.showToast({
                title: '保存成功'
              })
             }
          })
        }).catch(error => {
          // handle error
          console.log(error)
        })
      },
    ```

    

# 3.电影小程序案例

## 3.1.功能介绍和环境搭建

1. **引入vant组件库：**
   1. 将miniprogram在终端打开，运行cnpm init和cnpm i @vant/weapp -S --production命令下载vant组件库
   2. 微信开发者工具上方菜单栏->工具->构建npm->在miniprogram文件夹下出现miniprogram_npm
   3. 微信开发者工具右上角详情->本地配置->勾选使用npm模块
   4. 根据官方文档指引在.json文件中进行配置

## 3.2.电影列表

> 电影列表的信息是通过调用豆瓣api的接口获取的

- 发送请求的方式：

  - 在小程序端发送请求：

    - 发送方法：wx.request()，只支持https协议
    - 要经过ICP备案
    - 域名个数限制：20个

  - 在云函数中发送请求：（相当于通过小程序的后端去发送请求）

    - 第三方库（request、got、axios等），支持的协议根据第三方库来决定

    - 不经过备案也可以发送请求

    - 没有域名个数限制

    - 使用方法：

      - 首先新建一个云函数

      - 对新建的云函数右键使用外部终端打开，运行以下命令：

        ```
        cnpm install axios
        ```

      - 在云函数的js文件中引入axios，并在调用电影列表API时，增加headers对应参数（该参数一定要加，否则API会调用失败） 

        ```javascript
        const axios = require('axios')
        
        // 云函数入口函数
        exports.main = async (event, context) => {
          // 云函数中引入axios，并在调用电影列表API时，增加headers对应参数（该参数一定要加，否则API会调用失败）
          try {
            const {
            data
            } = await axios({
              // url是豆瓣电影列表的接口
              // event.start表示从第几条数据去取，event.count代表一次取多少条数据，这两个参数会在调用云函数时传入云函数
                url: `https://frodo.douban.com/api/v2/subject_collection/movie_showing/items?start=${event.start}&count=${event.count}&apiKey=054022eaeae0b00e0fc068c0c0a2102a`,
                method: 'get',
                headers: {
                "Host": "frodo.douban.com",
                "Connection": "keep-alive",
                'content-type': 'application/json',
                'Accept-Encoding': 'gzip,compress,br,deflate',
                'User-Agent': 'Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Mobile/15E148 MicroMessenger/8.0.2(0x18000236) NetType/WIFI Language/zh_CN',
                'Referer': 'https://servicewechat.com/wx2f9b06c1de1ccfca/81/page-frame.html'
              }
            })
                return data
            } catch (e) {
            console.log(e)
        }
        }
        ```

- movie.js文件中要做的事就是在加载电影界面的时候去发送请求，要调用moveList云函数

  - 如果要将请求到的数据展示在界面上，要在page的data区域中新建一个movieList列表，用于存放数据

  - 代码如下：

    ```javascript
    /**
       * 生命周期函数--监听页面加载
       */
      // 当生命周期到达该阶段的时候会自动调用
      // 即页面加载时会自动调用该函数
      onLoad: function (options) {
        wx.cloud.callFunction({
          name:'movieList',
          data:{
            start:this.data.movieList.length,
            count:10
          }
        }).then(res=>{
          console.log(res);
          //给movieList进行赋值，采用追加模式，防止覆盖掉之前的数据
          this.setData({
            movieList: this.data.movieList.concat(res.result.subject_collection_items)
        });
        }).catch(err=>{
          console.log(err);
        })
    
      },
     
    ```

  - 当滚动条滚动到底部时，仍要运行上述代码进行加载，因此上述代码可以被提取出来

    ```javascript
    getMovieList:function(){
        // 显示提示
        wx.showLoading({
          title: '加载中',
        })
        wx.cloud.callFunction({
          name:'movieList',
          data:{
            start:this.data.movieList.length,
            count:10
          }
        }).then(res=>{
          console.log(res);
          //给movieList进行赋值，采用追加模式，防止覆盖掉之前的数据
          this.setData({
            movieList: this.data.movieList.concat(res.result.subject_collection_items)
        });
        // 请求成功后隐藏提示框
        wx.hideLoading();
        }).catch(err=>{
          console.log(err);
          wx.hideLoading();
        })
    },
        
      /**
       * 生命周期函数--监听页面加载
       */
      // 当生命周期到达该阶段的时候会自动调用
      // 即页面加载时会自动调用该函数
      onLoad: function (options) {
        this.getMovieList(); 
      },
      /**
       * 页面上拉触底事件的处理函数
       */
      // 当滚动条滚动到底部时会自动调用该函数
      onReachBottom: function () {
        this.getMovieList();
      }
    ```

## 3.3.电影详情页

## 3.4.个人信息页



# 4.Promise语法的学习

## 4.1.promise状态

- Promise有三种状态：
  - pending 初始化状态
  - resolved 成功
  - reject 失败
- Promise对象的状态改变，只有两种可能：从pending变为resolved、从pending变为rejected，之后状态不会在改变了且状态不可逆。

## 4.2.promise常用基本语法

### 4.2.1.resolve & reject

1. New Promise 实例，要return

2. 传入函数，要有resolve、reject两个参数

3. 成功执行resolve，失败执行reject

4. then监听并接收结果

5. eg：

   ```javascript
   function loadImg(src) {
     const promise = new Promise(function(resolve,reject){
       img.onload = function () {
         resolve(img)
       }
       img.onerror = function () {
         reject()
       }
       img.src = src
     })
     return promise
   }
   ```

### 4.2.2.catch捕获

catch通常用于最后统一捕获,我我们try catch一样

Error和eject都可以捕获

```javascript
result.then(function(img){
      // dosomthing
    }).then(function(){
      // dosomthing
    }).catch(function(error){
      console.log(error)
    })
```

### 4.2.3.多个串联

如果我们希望我们的需求按顺序加载（例如，先加载用户信息，然后再通过用户信息渲染好友列表之类的）
我们需要在.then之后return 另外一个Promise 就可以了

```javascript
var src1 = 'www.xxx.com/1.jpg'
var src2 = 'www.xxx.com/2.jpg'
var img1 = loadImg(src1)
var img2 = loadImg(src2)

//链式操作
img1.then(function(img){
  console.log('图片一加载完成', img)
  return img2 //接下来就是对img2进行异步操作了
}).then(function(img){
  console.log('图片二加载完成', img)
}).catch(function(er){
  console.log(er)
})
```

### 4.2.4.Promise.all

Promise.all 接收一个Promose对象数组**待全部完成之后**一起执行success

.then方法接收的datas是一个数组,依次包含多个Promise返回值

```
Promise.all([result1,result2]).then(datas => {
  console.log(datas[0])
  console.log(datas[1])
})
```

### 4.2.5.Promise.race

和all不一样的是 **数组中只要有一个完成** 就执行success

```javascript
Promise.race([result1,result2]).then(data => {
  console.log(data)
})
```



**更多详见[代码](https://gitee.com/tao-zehua/wechat-applet-development)movie-test注释 以及[视频教程](https://www.imooc.com/video/19377)**





# 5.微信小程序进阶

## 5.1.用云函数发邮件

借助于第三方模块 Nodemailer，我们还可以实现使用云函数来发邮件。结合发邮件的功能，我们可以在用户注册了用户，或者评论有人回复，有重要的活动信息需要通知时发送邮件通知用户。用云函数这全套用户通知的流程实现起来也很简单。

### 5.1.1.开启 SMTP 服务

不同的邮件系统有着不同的 smtp 发送邮件服务器，端口号也会有所不同，这些都可以去相应的邮箱的设置里看到相关的说明的，这里仅以 QQ 邮箱为例，登录 QQ 邮箱，在**邮件设置**-**账户**里**开启 SMTP 服务**，QQ 邮箱的发送邮件服务器：[smtp.qq.com](http://smtp.qq.com/)，使用 SSL，端口号 465 或 587。

![img](http://cloudbasenet-1258016615.cosgz.myqcloud.com/20200616101335.png)

QQ 开启 SMTP 服务之后会获取到**邮件授权码**（邮件授权码不是邮箱密码），这个后面会用得到。

### 5.1.2.使用云函数发送邮件

使用开发者工具创建一个云函数，比如 nodemail，然后在 package.json**增加**nodemailer 最新版 latest 的依赖，并右键云函数目录选择在终端中打开输入命令 npm install 安装依赖：

```javascript
"dependencies": {

    "nodemailer": "latest"

  }
```

然后再在 index.js 里输入以下代码，并根据你的实际情况来修改一下里面的参数，如：

- auth 里面的**邮箱账号**和邮箱密码（不同的邮件系统可能机制不一样，QQ 邮箱为**邮箱授权码**）
- message 里面的 from 和 to 参数，分别为你的发件邮箱以及收件方的邮箱地址，你还可以填写 cc 和 bcc，抄送或密送给指定邮箱；
- host、port，这里为 QQ 邮箱的 SMTP 服务器地址和相应的端口，你如果使用的是其他邮件系统的，要注意修改；
- nodemailer 支持发送 text 文字内容、html 网页内容以及附件的形式，附件的格式支持 String、Buffer 或 Stream（各种文件），不过文件大小不同的邮箱是有限制的，也不宜过大，会影响云函数执行时间，建议大文件使用云存储链接；

```javascript
const nodemailer = require("nodemailer");

  let transporter = nodemailer.createTransport({
    host: "smtp.qq.com", //SMTP服务器地址

    port: 465, //端口号，通常为465，587，25，不同的邮件客户端端口号可能不一样

    secure: true, //如果端口是465，就为true;如果是587、25，就填false
    auth: {
      user: "xxxxx@qq.com", //你的邮箱账号

      pass: "xxxxx", //邮箱密码，QQ的需要是独立授权码，不是QQ邮箱的密码
    },
  });

  let message = {
    from: "来自陶泽华 <1923928217@qq.com>", //你的发件邮箱

    to: "tzh19850355091@163.com", //你要发给谁

    // cc:'',  支持cc 抄送

    // bcc: '', 支持bcc 密送

    subject: "欢迎大家参与云开发技术训练营活动",

    //支持text纯文字，html代码

    text: "欢迎大家",

    html: '<p><b>你好：</b></p>' +
      "<p>欢迎欢迎<br/></p>",

    attachments: [
      //支持多种附件形式，可以是String, Buffer或Stream

      {
        filename: "课程购买顺序图.jpg",

        content: Buffer.from(
          "iVBORw0KGgoAAAANSUhEUgAAABAAAAAQAQMAAAAlPW0iAAAABlBMVEUAAAD/" +
          "//+l2Z/dAAAAM0lEQVR4nGP4/5/h/1+G/58ZDrAz3D/McH8yw83NDDeNGe4U" +
          "g9C9zwz3gVLMDA/A6P9/AFGGFyjOXZtQAAAAAElFTkSuQmCC",

          "base64"
        ),
      },
    ],
  };

  let res = await transporter.sendMail(message);

  return res;
```

部署上传云函数之后，在小程序端或者云开发控制台调用该云函数就能收到邮件啦，这个只是定向给某个发送邮件，只适合发给管理员进行邮件通知的场景。

### 5.1.3. 邮箱功能的拓展与应用

尽管邮件已经没落，但是邮箱几乎是所有互联网用户都会使用的一个互联网产品，用云函数结合邮件的发送可以拓展和传统的后端一样的发送邮件的能力。

#### 5.1.3.1.结合云数据库给指定的人发邮件

当用户在小程序端进行一些业务操作时，我们可以结合数据库定向给该用户或目标用户发邮件，比如用户绑定注册或找回密码，当用户 A 给用户 B 写的文章或留言评论时可以给 B 发邮件，当用户参与活动需要通知时，管理员可以给目标用户发邮件等。不同的业务场景接收邮件的人也会不同，邮件里面的内容根据业务的需求也会有所不同，因此在邮件发送的过程中，数据库扮演着非常重要的角色。

> 不过由于 QQ 邮箱是个人邮件系统，每天只能发送几百封邮件，不太适合用户量比较大的小程序作为企业业务来进行邮件的发送。

#### 5.1.3.2.实现密码校验与邮件的定时发送

当用户在个人资料里绑定自己的邮箱时，可以发送邮件以及校验码，校验码可以是数据库的一个字段，它的值可以是一些随机生成的字符串，但是有一定的生命周期，比如半个小时之后会失效，这个自动失效的操作则需要使用到**定时触发器**；邮件也可以是周报、日报的周期性定时发送，在每天或每周的某个时间点，批量收集当天或当周的数据自动发送给用户，这个也是依赖**定时触发器**。

## 5.2.定时触发器

> 任何可以产生事件，触发云函数执行的均可以被称为触发器，而定时触发器则是可以处理周期性的事情，比如时报、日报、周报等通知提醒，也可以处理倒计时任务，比如节假日、纪念日以及你可以指定一个具体时间的倒计时任务，除此之外，定时触发器还可以用来周期性处理一些定时任务。比如定期清理一些不必要的数据，定期更新集合内的数据。

### 5.2.1. 定时触发器使用说明

#### 1、定时触发器的配置与部署

配置了定时触发器的云函数，会在相应时间点被自动触发，云函数的返回结果不会返回给调用方。在对某个云函数使用定时触发器前，**首先要保证**该云函数在小程序端可以调用成功，更准确的说是能够在不传入参数的情况下在云开发控制台的云端测试能调试成功（小程序端调用有登录态）。
在配置文件 config.json 里进行类似如何格式的配置，config.json 严格遵循配置文件所要求的格式，比如数组最后一项不能有逗号`,`；配置文件里**不能有注释**等

- triggers 字段是触发器数组，但是目前云函数只支持一个触发器，即数组只能填写一个，不可添加多个；
- name 是触发器的名字，最大支持 60 个字符，支持 a-z, A-Z, 0-9, - 和 _，必须以字母开头；
- type 为触发器类型，timer 是定时触发器
- config 是触发器的定时配置，里面为 cron 表达式，cron 有七个必需字段，不能多也不能少（以下为每天早上 9 点到 12 点每隔 5 秒触发一次）；

```
{

  "triggers": [

    {

      "name": "tomylove",

      "type": "timer",

      "config": "*/5 * 9-12 * * * *"

    }

  ]

}
```

当我们在修改触发器配置文件 config.json 后，首先鼠标右键 config.json 选择“**云函数增量上传：更新文件**”，然后再右键 config.json 选择“**上传触发器**”。这里的“云函数增量上传：更新文件”是让云函数端的触发器文件更新；而“上传触发器”则是让触发器开始生效执行。如果在云函数端的触发器没有更新的情况下就“上传触发器”来执行定时触发，文件可能没有更新，执行的还是旧的触发器内容。当我们想暂停或删除触发器时，可以右键选择“**删除触发器**”。

#### 2、Cron 表达式语法

Cron 表达式有七个**必填**字段，按空格分隔，每一个字段都有它的含义对应着不同的时间点，表达式的取值都为整数且为时间制的范围(**注意月在星期的前面**)：

| 第一位      | 第二位       | 第三位       | 第四位     | 第五位                         | 第六位                          | 第七位           |
| ----------- | ------------ | ------------ | ---------- | ------------------------------ | ------------------------------- | ---------------- |
| 秒（0-59 ） | 分钟（0-59） | 小时（0-23） | 日（1-31） | 月（1-12或三个字母的英文缩写） | 星期（0-6或三个字母的英文缩写） | 年（1970~2099 ） |

下面是 cron 表达式的案例，以及我们需要了解一下 cron 表达式里的通配符以及直接写数字的含义：

- `,`表示并集，在时间的表述里是“**和**”的意思，比如在“小时”字段中， `1,2,3`表示 1 点、2 点和 3 点；
- `-`指定范围的所有值，在时间的表述里是“**到**”的意思，比如在“日”字段中，`1-15`包含指定月份的 1 号到 15 号；
- `*`表示所有值，在时间的表述里是“**每**”的意思，比如在“小时”字段中，`*`表示每小时；
- `/`指定步长，在时间的表述里是“**隔**”的意思，比如在“秒”字段中，`*/5`表示每隔 5 秒；
- 直接写数字，在时间的表述里是“**第**”（时间点）的意思，比如在“月”字段中，`5`表示每月的第 5 日；

```javascript
//表示每隔5秒触发一次，

*/5  *  *  *  *  *  *


//表示在每月的1日的凌晨2点触发

0  0  2  1  *  *  *


//表示在周一到周五每天上午10:15触发

0  15  10  *  *  MON-FRI *


//表示在每天上午10点，下午2点，4点触发

0  0  10,14,16  *  *  *  *


//表示在每天上午9点到下午5点内每半小时触发

0  */30  9-17  *  *  *  *


//表示在每个星期三中午12点触发

0  0  12  *  *  WED *
```

> 云开发的触发器暂时不支持多个定时触发器的叠加

### 5.2.2. 用定时触发器调用云函数

定时触发器的使用非常简单，使用开发者工具新建一个云函数比如 trigger，然后在 index.js 里输入以下代码：

```javascript
const cloud = require("wx-server-sdk");

cloud.init({
  env: cloud.DYNAMIC_CURRENT_ENV,
});

exports.main = async (event, context) => {
  console.log(event);

  return event;
};
```

再在 trigger 云函数目录下的 config.json（如果没有这个文件，就创建一个），然后输入以下触发器，为了调试方便，我们可以每隔 5 秒触发一次：

```json
{

  "permissions": {

    "openapi": [

    ]

  },

  "triggers": [

    {

      "name": "tomylove",

      "type": "timer",

      "config": "*/5 * * * * * *"

    }

  ]

}
```

然后分别右键 index.js 和 config.json，选择“云函数增量上传：更新文件”，然后再来右键 config.json 选择“上传触发器”。云函数就会每隔 5 秒自动触发，相关的日志我们可以在开发者工具的云开发控制台以及腾讯云云开发网页控制台的云函数的日志里查看。

注意小程序端调用 trigger 云函数返回的 event 对象，和使用定时触发器返回的 event 对象的不同，用定时触发器触发云函数是获取不到 openId 的，同时这里有一个 Time 时间是时区为 UTC+0 的时间，比北京时间晚 8 个小时：

```
//在小程序端调用trigger云函数之后返回的event对象

{

  "userInfo":{

  "appId":"wxda99******7046",

  "openId":"oUL-m5F******buEDsn8"

  }

}


//使用定时触发器触发云函数之后返回的event对象

{

  "Message":"",

  "Time":"2020-06-11T11:43:35Z",

  "TriggerName":"tomylove",

  "Type":"timer",

  "userInfo":{

    "appId":"wxda99********46"

    }

}
```

### 5.2.3.定时触发器的应用

#### 1、结合消息推送

这里的消息推送不仅仅只是指订阅消息，还可以是统一服务消息、公众号的消息（可以用云函数开发微信公众号）、小程序内自己开发的通知（只是用户只有在打开小程序时才能看到）、Email 邮件等等。

比如用户订阅了日报、周报、月报等**周期性的**通知提醒或者我们需要给用户发送一些汇总信息，就可以固定写一个定时触发器，比如我们需要给指定用户发送工作周报，每周五晚上 17 点 30 分就定时从数据库获取数据发送消息，cron 表达式写法如下：

```
*  30  17  *  *  FRI  *
```

还可以用来处理一些倒计时（指定时间点）的任务，比如节假日、纪念日以及一些活动时间节点（定时触发器目前只能一个云函数配一个触发器，但是可以提前管理），比如我们希望在六一儿童节的早上 9 点调用云函数给指定用户群体发送消息：

```
0  0  9  1  6  *  *
```

当然这样的具体时间点显得过于的不灵活，但是如果把**时间与云开发数据库**结合起来，灵活性就会大很多，比如在运营上每天早上 11 点是你们用户访问最多的时间点，你只需要写一个云函数，把所有的活动都在这个时间点来推送，让定时触发器每天这个时间点都触发，有活动（数据库里有数据）就会发消息，如果没有就不发（云函数调用一次的成本极低）。

如果是实时数据，我们还可以把定时触发器的频率调高，每 5 秒就触发一次，比如我们的数据库只要有最新的数据，就会发消息给指定用户。尽管不是完全的实时，但是 5 秒的频率和实时的差别也就不大了。你也可以根据情况，来调整触发器的频率，毕竟 5 秒和 1 分钟的频率给用户的体验差异并没有太大，但是成本却是 12 倍的关系。

可能你还希望在指定的时间段才触发云函数，比如你只希望在工作日、或者在早上 9 点到晚上 18 点才触发，在指定的时间段才触发既可以让触发更精准不扰民，也可以节约成本，比如下面的触发器就是工作日早上 9 点到 12 点和下午 14 点到 18 点这个时间段，每 5 秒触发一次。

```
*/5  *  9-12,14-18 * MON,TUE,WED,THU,FRI *
```

> 从以上案例我们可以了解到，云函数的定时触发可以来自于 cron 表达式的配置，我们可以指定时间点时间段和频率来达到我们想要的效果，同时这个时间“也可以来自于数据库的配置”（伪装），意思是我们可以设置触发器的时间段或频率，如果数据库里有数据就发送，没有数据就不发送，这样就可以达到触发器在时间上的灵活性了。

#### 2、实时获取数据

有的时候我们的数据并不是来自于数据库，而是来自于第三方服务，比如前面介绍过的历史上的今天的 API，天气的 API，知乎日报的 API 等等，以及一些 webhook，这些 API 和第三方服务提供的是 json 格式的文件，API 的数据也会随时更新，但是它们更新了却并不会主动通知我们，这时我们可以使用定时触发器向这些 API 发起请求，如果数据出现更新，我们就可以将更新的数据存储到我们的数据库或者进行其他处理，比如企业微信的机器人等机器人通知服务就是如此。

当然定期获取的数据还可以是爬虫，比如我们可以定期抓取指定关键词的新闻或者指定网站的动态，当爬虫获取到了不同的数据的时候，就将最新的动态以机器人消息或者其他方式进行及时的处理。

也就是说，我们无法实时监听到第三方 API 或者网站数据的变动，但是可以用定时触发器来发起请求或者爬虫抓取数据，通过数据的变化来达到“实时”获取数据的目的。

#### 3、自动化处理

在数据库的设计里，我们就提到有时候需要对数据库里的数据进行定期的备份与删除等清理维护工作，比如超过一定时间的日志，具有很强时效性的活动数据，以及为了性能考虑而做的虚假删除（数据库性能与优化有介绍）等，毕竟数据库有一定的存储成本而且过多无用数据也会影响数据库的性能，我们可以写一个云函数用定时触发器来执行此类任务。

我们还可以在用户并发比较少的时间段（比如凌晨几点）来处理一些比较耗云函数、数据库性能的任务，比如图片的审核与裁剪、缩略等处理，用户评论是否包含敏感词汇（尽管经过安全处理，但是有时候我们还会设置特别的敏感词），数据的汇总，云存储里废弃文件的删除，用户信息是否完整等等。

也就是说，结合定时触发器，我们可以实现一些任务的自动化处理。

#### 3、密集型任务分流

我们知道云函数在处理一些复杂性的任务时是有一些限制的，一是执行时间的限制，建议在设置时执行时间一般不要超过 20s，最长不要超过 60s；二是并发的限制，云函数最大的并发为 1000；三是云函数在查询数据库时一次可以获取最多 1000 条的数据，面对这三个限制，我们应该如何处理密集型的任务呢，比如发送 100 万封邮件，导出几百万条数据到 Excel，发送十万级的订阅消息或消息等等，这个时候就可以使用到定时触发器来处理了。

借助于定时触发器，我们可以将需要耗时较长、对并发要求较高以及数据库请求等的任务进行**分批处理**，比如我们要给 100 万人发邮件：云函数发起数据库请求，一次只请求 1000 条**未发送过邮件**的用户（用 where 条件查询某个字段，比如`status:false`），然后将邮件发给 1000 个人（可以参考前面的邮件发送），发完邮件并对这 1000 条数据进行标记（比如使用更新指令将 status 改为 true），这样下次查询未发送过邮件的用户时，就不会重复发送了。通过定时触发器，每 2 秒执行一次发送任务，几十分钟就可以处理完任务。

## 5.3.短信发送

结合一些第三方提供的短信 API，使用云开发的云函数也能发送短信验证码、系统和活动通知等，下面以腾讯云的短信服务为例。

### 5.3.1.开通腾讯云短信服务

#### 1、开通短信服务

登录[短信控制台](https://console.cloud.tencent.com/smsv2)，这里的账号不限于小程序的账号，其他账号也可以；也不限于是个人账号还是企业账号，不过账号需要进行实名认证，个人认证用户只能发送短信验证码、短信通知等，不能用于营销短信；企业认证用户可以发送短信验证码、短信通知、营销短信等。如果账号已经认证，直接申请短信服务就可以开通了。

#### 2、创建应用

创建应用可用于个性化管理短信发送任务，例如设置不同的发送频率和发送超量提醒等。打开左侧菜单里的**应用管理**-**应用列表**，点击**创建应用**，应用名称可以为你的小程序名称+云开发，便于区分管理。创建后，会有一个`SDKAppID`，这个之后会用到。

#### 3、创建签名和正文模板

国内短信由签名+正文组成，签名符号为【】，发送短信内容时必须带签名。所以要发送短信，需要申请**短信签名**和**正文模板**，两者都通过审核后，就可以开始发送短信了。

**1、创建签名**

打开左侧菜单里的**国内短信**-**签名管理**，点击**创建签名**，创建完签名后，这个`签名内容`之后会用到。

- 签名用途：选择【自用（签名为本账号实名认证的公司、网站、产品名等）】。
- 签名类型：选择【小程序】。
- 签名内容：输入公司名或小程序名或产品名称
- 证明类型：选择小程序设置页面截图，然后上传小程序**设置页面**截图，可以参考案例；

![img](http://cloudbasenet-1258016615.cosgz.myqcloud.com/20200616101929.png)

**2、创建正文模板**

打开左侧菜单里的**国内短信**-**正文模板管理**，点击**创建正文模板**，创建完模板后，会有一个模板`ID`，这个之后会用到，也要记住你模板的变量位置。

- 模板名称，建议带有明确目的的名称，比如“注册通知”、“购买成功反馈”等；
- 短信类型：选择【普通短信】
- 短信内容：比如“您正在申请手机注册，验证码为：{1}，{2}分钟内有效！”，这里的`{1}`和`{2}`是你要在代码里传入的变量，变量的编码必须是从{1}开始，传入变量时也要按照顺序传入

![img](http://cloudbasenet-1258016615.cosgz.myqcloud.com/20200616101948.png)

#### 3、获取安全凭证

在使用云 API 之前，用户首先需要在腾讯云控制台上申请安全凭证(API 密钥)，安全凭证包括 SecretID 和 SecretKey。打开腾讯云访问密钥的[API 密钥管理](https://console.cloud.tencent.com/cam/capi)，点击**新建密钥**，就可以创建密钥了，创建之后，就可以看到 `SecretID`和`SecretKey`，这两个之后会用到。

> API 密钥是构建腾讯云 API 请求的重要凭证，使用腾讯云 API 可以操作你这个账号名下的所有腾讯云资源，一定要妥善保管和定期更新，不要分享给别人或者上传到网络上。

![img](http://cloudbasenet-1258016615.cosgz.myqcloud.com/20200616102014.png)

### 5.3.2.使用云函数发送短信

使用开发者工具新建一个云函数，比如 sms，打开云函数目录中的 package.json ，新增最新版 tencentcloud-sdk-nodejs 依赖，右键云函数目录选择在终端中打开输入命令 npm install 安装依赖：

```json
"dependencies": {

  "wx-server-sdk":"latest",

  "tencentcloud-sdk-nodejs":"latest"

}
```

然后再在云函数的目录下面新建一个 config 文件夹，在 config 文件夹里创建一个 config.js，云函数的目录结构如下图所示：

```
sms // 云函数目录

├── config //config文件夹

│   └── config.js //config.js文件

└── index.js

└── config.json

└── package.json
```

然后再在 config.js 里输入以下代码，填入获取安全凭证里的 SecretID 和 SecretKey:

```js
module.exports = {
  secretId: "wxda99ae45313257046",

  secretKey: "josgjwoijgowjgjsogjo",
};
```

再在 index.js 里输入以下代码，代码的内容比较多，但是基本都是从腾讯云短信的技术文档里直接 Copy 过来的，我们只需要改里面相应的参数即可，比如

- req.SmsSdkAppid 为**创建应用**环节里的`SDKAppID`，
- req.Sign 为创建签名里的`签名内容`，
- req.TemplateID 为创建正文模板环节里的模板`ID`，
- req.TemplateParamSet 为模板内容里的变量，值为数组，有多少个变量就往数组里填多少个字符串
- req.PhoneNumberSet 为用户的手机号码，测试时可以填你自己的

修改完以上内容之后，就可以触发该云函数给相应的手机号发送短信了：

```javascript
const cloud = require("wx-server-sdk");

const tencentcloud = require("tencentcloud-sdk-nodejs");

cloud.init({
  env: cloud.DYNAMIC_CURRENT_ENV,
});

const config = require("./config/config.js");

const { secretId, secretKey } = config;

exports.main = async (event, context) => {
  const smsClient = tencentcloud.sms.v20190711.Client;

  const models = tencentcloud.sms.v20190711.Models;

  const Credential = tencentcloud.common.Credential;

  const ClientProfile = tencentcloud.common.ClientProfile;

  const HttpProfile = tencentcloud.common.HttpProfile;

  let cred = new Credential(secretId, secretKey);

  let httpProfile = new HttpProfile();

  httpProfile.reqMethod = "POST";

  httpProfile.reqTimeout = 30;

  httpProfile.endpoint = "sms.tencentcloudapi.com";

  let clientProfile = new ClientProfile();

  clientProfile.signMethod = "HmacSHA256";

  clientProfile.httpProfile = httpProfile;

  let client = new smsClient(cred, "ap-guangzhou", clientProfile);

  let req = new models.SendSmsRequest();

  req.SmsSdkAppid = "1400364657";

  req.Sign = "HackWeek";

  req.ExtendCode = "";

  req.SenderId = "";

  req.SessionContext = "";

  req.PhoneNumberSet = ["+86185****3"];

  req.TemplateID = "597853";

  req.TemplateParamSet = ["1234", "5"];

  client.SendSms(req, function (err, response) {
    if (err) {
      console.log(err);

      return;
    }

    console.log(response.to_json_string());
  });
};
```

## 5.4.HTTP处理

> 本文以axios为例

### 5.4.1.了解网络数据 API

```json
//知乎日报的最新话题
https://news-at.zhihu.com/api/4/news/latest

//知乎日报某一个话题的内容
https://news-at.zhihu.com/api/4/news/9714883

//v2ex论坛的最新主题
https://www.v2ex.com/api/topics/latest.json

//CNode论坛的最新话题
https://cnodejs.org/api/v1/topics
```

以上所返回的数据类型都是 json 格式

#### 5.4.1.2.练手 API 资源推荐

这里推荐几个程序员经常会拿来练手的 API 资源，你可以使用这些 API 来做网站、小程序、移动端（iOS、安卓）、桌面端，也可以用于各种框架比如 Vue、React、Flutter 等等，数据没变，只是解决方案不同。

- [聚合 API](https://www.juhe.cn/)：一个比较全面的综合性 API 服务平台
- [即速 API](https://www.jisuapi.com/)：也是提供一些综合性的 API 服务
- [V2EX API](https://www.v2ex.com/p/7v9TEc53)：v2ex 论坛是很多程序员经常会光顾的综合性技术论坛
- [CNode API](https://cnodejs.org/api/)：Nodejs 交流论坛
- [和风天气](https://www.heweather.com/)：含天气预报、空气质量、实况天气等数据
- [Github API](https://developer.github.com/v3/)：Github 是所有程序员都（必须）会使用的网站
- [知乎日报 API](https://github.com/izzyleung/ZhihuDailyPurify/wiki/知乎日报-API-分析)：知乎日报 API 分析

### 5.4.2.get 请求

使用开发者工具，创建一个云函数，如 axios，然后在 package.json 增加 axios 最新版 latest 的依赖并用 npm install 安装：

```json
"dependencies": {

  "wx-server-sdk":"latest",

  "axios": "latest"

}
```

然后在 index.js 里输入以下代码，下面还以知乎日报的 API 为例：

```javascript
const cloud = require("wx-server-sdk");

cloud.init({
  env: cloud.DYNAMIC_CURRENT_ENV,
});

const axios = require("axios");

exports.main = async (event, context) => {
  const url = "https://news-at.zhihu.com/api/4/news/latest";

  try {
    const res = await axios.get(url);

    //const util = require('util')

    //console.log(util.inspect(res,{depth:null}))

    return res.data;
  } catch (e) {
    console.error(e);
  }
};
```

在小程序端调用这个云函数，就能返回从知乎日报里获取到的最新文章和热门文章，云函数端获取知乎日报的数据就**不需要添加域名校验**，比小程序端的 wx.request 方便省事很多。

> 注意，在上面的案例中，我们返回的不是整个 res(response 对象)，而是 response 对象里的 data。直接返回整个 res 对象，会报`Converting circular structure to JSON`的错误，如果你想返回整个 res，可以取消上面代码里面的注释。Node 的`util.inspect(object,[showHidden],[depth],[colors])`是一个将任意对象转换为字符串的方法，通常用于调试和错误输出。

上面的知乎链接本来就是 API，返回的是 json 格式的数据，所以可以直接使用 axios.get()，axios 还可以用于爬虫，爬取网页，比如下面的代码就是爬取百度首页，并返回首页里的`<title></title>`里的内容（也就是网页的标题）：

```javascript
const cloud = require("wx-server-sdk");

cloud.init({
  env: cloud.DYNAMIC_CURRENT_ENV,
});

const axios = require("axios");

exports.main = async (event, context) => {
  try {
    const res = await axios.get("https://baidu.com");

    const htmlString = res.data;

    return htmlString.match(/<title[^>]*>([^<]+)<\/title>/)[1];
  } catch (e) {
    console.error(e);
  }
};
```

> 如果想使用云函数做爬虫后台，抓取网页数据，可以使用 cheerio 和 puppeteer 等第三方开源依赖。

### 5.4.3.post 请求

结合前面在网络 API 里讲过的聚合数据[历史上的今天 API](https://www.juhe.cn/docs/api/id/63)，我们也可以在云函数端发起 post 请求：

```javascript
const now = new Date(); //在云函数字符串时间时，注意要修改云函数的时区，方法在云函数实用工具库里有详细介绍

const month = now.getMonth() + 1; //月份需要+1

const day = now.getDate();

const key = ""; //你的聚合KEY

const url = "http://api.juheapi.com/japi/toh";

const cloud = require("wx-server-sdk");

cloud.init({
  env: cloud.DYNAMIC_CURRENT_ENV,
});

const axios = require("axios");

exports.main = async (event, context) => {
  try {
    const res = await axios.post(url, {
      key: key,

      v: 1.0,

      month: month,

      day: day,
    });

    // const res = await axios.post(`url?key=${key}&v=1.0&month=${month}&day=${day}`)

    return res;
  } catch (e) {
    console.error(e);
  }
};
```

### 5.4.4.使用 axios 下载文件

要使用 axios 下载文件，需要将 axios 的 responseType 由默认的 json 修改为 stream，然后将下载好的文件上传到云存储里，也可以将下载好的文件写入到云函数临时的 tmp 文件夹里，用于更加复杂的操作。

```javascript
const cloud = require("wx-server-sdk");

cloud.init({
  env: cloud.DYNAMIC_CURRENT_ENV,
});

const axios = require("axios");

//const fs = require('fs');

exports.main = async (event, context) => {
  try {
    const url =
      "https://tcb-1251009918.cos.ap-guangzhou.myqcloud.com/weapp.jpg";

    const res = await axios.get(url, {
      //将 axios 的 responseType 由默认的 json 修改为 stream
      responseType: "stream",
    });

    //Nodejs Buffer 类的引入，让云函数也拥有操作文件流或网络二进制流的能力，云函数通过 downloadFile 接口从云存储里下载的数据类型就是 Buffer，以及 uploadFile 接口可以将 Buffer 数据上传到云存储。Buffer 类在全局作用域中，因此我们无需使用 require('buffer')引入。
    const buffer = res.data;

    //我们也还可以将下载好的图片保存在云函数的临时文件夹里

    // const fileStream = await fs.createReadStream('/tmp/axiosimg.jpg')

    return await cloud.uploadFile({
      cloudPath: "axiosimg.jpg",

      fileContent: buffer,
    });
  } catch (e) {
    console.error(e);
  }
};
```

## 5.5.订阅消息

订阅消息是小程序能力中的重要组成，当用户自主订阅之后，可以向用户以服务通知的方式发送消息的能力，当用户点击订阅消息卡片可以跳转到小程序的页面，这样就可以实现服务的闭环和更优的体验，提高活跃度和用户粘性。

### 5.5.1.获取订阅消息授权

#### 1、小程序端获取订阅消息授权次数

要获取订阅消息授权，首先要调用接口 **wx.requestSubscribeMessage**，这个接口会调起小程序订阅消息界面，返回用户订阅消息的操作结果。注意这个接口只能在小程序端使用 tap 点击或支付完成后触发。如果是使用页面加载或其他非用户点击类的事件来调用这个接口，就会报`requestSubscribeMessage:fail can only be invoked by user TAP gesture`的错误。

要调用 wx.requestSubscribeMessage，我们首先要有订阅消息的模板 ID（消息模板id在[微信公众平台(mp.weixin.qq.com)-功能-订阅消息]中配置。每个tmplId对应的模板标题需要不相同，否则会被过滤），一次性模板 id 和永久模板 id 不可同时使用，基础库 2.8.4 之后一次性可以调起 3 个模板 ID（不能多于 3 个）。wx.requestSubscribeMessage 的参数 tmplIds 是数组可以容纳 3 个模板 ID，当用户点击授权弹窗，三个模板 ID 都是默认勾选的，只要用户点击允许，就会同时给三个模板 ID 累积次数；如果用户取消勾选了其中一个模板 ID，并点击总是允许，那另外两个勾选的模板 ID 将不会再有授权弹窗。

使用开发者工具新建一个页面，如 subscribe，然后在 subscribe.wxml 里输入以下代码，我们通过点击 tap 来触发事件处理函数：

```xml
<button bindtap="subscribeMessage">订阅订阅消息</button>
```

然后再在 subscribe.js 里输入以下代码，我们在事件处理函数 subscribeMessage 里调用 wx.requestSubscribeMessage 接口：(**在这儿写回调函数时一定要与下面的写法保持一致，不能写成.then的形式**)

```javascript
subscribeMessage() {

  wx.requestSubscribeMessage({
    tmplIds: [
      "qY7MhvZOnL0QsRzK_C7FFsXTT7Kz0-knXMwkF1ewY44",//模板，自行获取

      "RCg8DiM_y1erbOXR9DzW_jKs-qSSJ9KF0h8lbKKmoFU",

      "EGKyfjAO2-mrlJQ1u6H9mZS8QquxutBux1QbnfDDtj0
    ],
    success(res) {
      console.log("订阅消息API调用成功：",res)
    },
    fail(res) {
      console.log("订阅消息API调用失败：",res)
    }
  })
},
```

然后在手机上进行**真机调试**这个接口，点击订阅消息 button，就能弹出授权弹窗。

- 当用户点击“允许”就会累积一次授权，如果点击 N 次允许就能累积 N 次授权，这个授权是长期的，没有时间限制，你可以在一天内发完 N 次授权，也可以在未来分批次发完；累积的授权次数被消耗完之后，还继续发，就会报错`"errcode":"43101","errmsg":"user refuse to accept the msg hint..."`。
- 当用户勾选了订阅面板中的“总是保持以上选择，不再询问”时，且允许或拒绝之后，**订阅消息的授权弹窗则永远不会再弹出**，订阅消息也会被添加到用户的小程序设置页，我们可以通过 **wx.getSetting** 接口可获取用户对相关模板消息的订阅状态。wx.getSetting 的 withSubscriptions 可以获取用户订阅消息的订阅状态，当然**只能返回**用户勾选过订阅面板中的“总是保持以上选择，不再询问”的订阅消息。
- 如果用户勾选了总是允许，那由于用户点击按钮都不会弹出授权弹窗，用户点击了授权按钮仍然会累积授权，起到一个静默收集授权次数的效果。也就是说，如果你通过 wx.getSetting 的 withSubscriptions 获取到用户对某条模板消息勾选了“总是保持以上选择，不再询问”，那你可以**设置一个静默收集用户授权次数的 button**，用户不会弹出授权弹窗，但是会累积授权次数。

注意该接口调用成功之后返回的对象，[TEMPLATE_ID]是动态的键，即模板 id，值包括'accept'、'reject'、'ban'。'accept'表示用户同意订阅该条 id 对应的模板消息，'reject'表示用户拒绝订阅该条 id 对应的模板消息，'ban'表示已被后台封禁，如下所示（以下值仅为案例）：

```json
{errMsg: "requestSubscribeMessage:ok", RCg8DiM_y1erbOXR9DzW_jKs-qSSJ9KF0h8lbKKmoFU: "accept", qY7MhvZOnL0QsRzK_C7FFsXTT7Kz0-knXMwkF1ewY44: "reject", EGKyfjAO2-mrlJQ1u6H9mZS8QquxutBux1QbnfDDtj0: "accept"}
```

**订阅消息的累积次数决定了我们是否可以给用户发送订阅消息，也决定了可以发送几次**，因此记录用户给某个模板 ID 授权了多少次这个也就显得很重要了，比如我们可以结合接口返回的 res 对象和 inc 原子自增在数据库里记录订阅次数，当发送一次也会消耗一次，再用 inc 自减：

```javascript
  subscribeMessage() {
  	const tmplIds= [
      "qY7MhvZOnL0QsRzK_C7FFsXTT7Kz0-knXMwkF1ewY44",
      "RCg8DiM_y1erbOXR9DzW_jKs-qSSJ9KF0h8lbKKmoFU",
      "EGKyfjAO2-mrlJQ1u6H9mZS8QquxutBux1QbnfDDtj0"
    ];
    wx.requestSubscribeMessage({
      tmplIds: tmplIds,
      success(res) {
        console.log("订阅消息API调用成功：",res)
        tmplIds.map(function(item,index){
          if(res[item] === "accept"){
            console.log("该模板ID用户同意了",item)
            //可以使用原子自增指令inc往数据库里某个记录授权次数的字段+1
          }
        })
      },
      fail(res) {
        console.log("订阅消息API调用失败：",res)
      }
    })
  },
```

#### 2、订阅消息授权与次数累积实践

订阅消息最核心的在于用户的授权与授权次数，在写订阅消息代码时或在发送订阅消息之前，要先用数据库记录用户是否已经授权以及授权的次数，关于订阅消息的授权次数的累积需要再说明的是：

- **只能在小程序端**通过调用 wx.requestSubscribeMessage 来进行授权以及累积授权次数，**wx.requestSubscribeMessage 也不能写在云函数端；**
- 只能记录和累积**当前用户**的授权与授权次数，这个要注意分清楚，比如我们希望学生点击之后通知老师、老师点击之后通知学生，这个前提始终是**你要通知谁，谁必须有授权或授权次数才能通知；通知谁就会消耗谁的授权次数**。比如要做到学生完成作业点击按钮就可以通知老师，此时学生不必有授权次数，老师必须有，而订阅消息的通知则需要在云函数端进行；
- 授权次数**只能增不能减**，如果你想实现用户订阅了订阅消息之后（使用的是 wx.requestSubscribeMessage 接口），又取消了该订阅消息的通知（不需要使用 wx.requestSubscribeMessage 接口），你可以在数据库里记录，不再发消息给用户，但是用户的授权次数并没有减少。所以取消订阅我们可以使用布尔型字段，而授权次数我们可以使用整数方便原子操作。

订阅消息的种类很多，比如有的订阅消息用户接收一次之后就不会再接收，这时我们侧重于记录订阅消息是否被用户同意就可以了；但是有的订阅消息记录用户授权的次数有利于我们可以更好的为用户服务，比如日报、周报、活动消息等一些与用户交互比较频繁的信息。在前面我们已经多次强调了云数据库的原子操作，这里再以订阅消息次数累积的增加（授权只能增加）为例，来看原子操作是如何处理的。

使用云开发控制台在**云数据库**新建一个 messages 集合，messages 集合的记录结构如下所示，在设计上我们把同一个用户多个不同类型的订阅消息内嵌到一个数组 templs 里面。

```
_id: ""; //可以直接为用户的openid，这样我们可以使用db.collection('messages').doc(openid)来处理；不过我们的案例的_id不是openid

_openid: ""; //云开发自动生成的openid

templs: [
  {
    //把用户授权过的模板列表都记录在这里

    templateId: "qY7MhvZOnL0QsRzK_C7FFsXTT7Kz0-knXMwkF1ewY44", //订阅

    page: "",

    data: {}, //订阅消息内容对象，建议内嵌到里面，免得查两次

    status: 1, //用户对该条模板消息是否接受'accept'、'reject'、'ban'，

    subStyle: "daily", //订阅类型，比如是每天daily，还是每周weekly

    done: false, //本次是否发送了

    subNum: 22, //该条订阅消息用户授权累积的次数；
  },
  {},
];
```

下面是用户在小程序端点击订阅消息之后的完整代码，记录不同的订阅消息被用户点击之后，次数的累积。代码没有记录用户是否拒绝 reject，如果业务上有需要也是可以记录的，不过拒绝不存在累积次数的问题。

```javascript
subscribeMessage() {

  const that = this

  //模板ID建议放置在数据库中，便于以后修改

  const tmplIds= [

    "qY7MhvZOnL0QsRzK_C7FFsXTT7Kz0-knXMwkF1ewY44",

    "RCg8DiM_y1erbOXR9DzW_jKs-qSSJ9KF0h8lbKKmoFU",

    "EGKyfjAO2-mrlJQ1u6H9mZS8QquxutBux1QbnfDDtj0"

  ];

  wx.requestSubscribeMessage({

    tmplIds:tmplIds,

    success: res => {

      console.log("订阅消息API调用成功：",res)

      that.addMessages().then( id =>{

        tmplIds.map(function(item,index){

          if(res[item] === "accept"){

            console.log("该模板ID用户同意了",item)

            that.subscribeNum(item,id)

          }
        })
      })
    },

    fail(res) {
      console.log("订阅消息API调用失败：",res)
    }
  })
},

async addMessages(){

  //查询用户订阅过的订阅消息，只会有一条记录，所以没有limit等限制

  const messages = await db.collection('messages').where({

    _openid:'{openid}'

  }).get()


  //如果用户没有订阅过订阅消息，就创建一条记录

  if(messages.data.length == 0){

    var newMsg = await db.collection('messages').add({

      data:{

        templs:[]

      }

    })

  }

  var id = messages.data[0] ? messages.data[0]._id : newMsg._id

  return id

},


async subscribeNum(item,id){

  //注意传入的item是遍历，id为addMessages的id

  const subs = await db.collection('messages').where({

    _openid:'{openid}',

    "templs":_.elemMatch({

      templateId:item

    })

  }).get()



  console.log('用户订阅列表',subs)

  //如果用户之前没有订阅过订阅消息就创建一个订阅消息的记录

  if(subs.data.length == 0){

    db.collection('messages').doc(id).update({

      data: {

        templs:_.push({

          each:[{templateId:item,//订阅

            page:"",

            data:{},

            status:1,

            subStyle:"daily",

            done:false,

            subNum:1}],

          position:2

        })

      }

    })

  }else{

    db.collection('messages').where({

      _id:id,

      "templs.templateId":item

    })

    .update({

      data:{

        "templs.$.subNum":_.inc(1)

      }

    })

  }

}
```

这里的`"templs.$.subNum":_.inc(1)`就是当用于同意哪条订阅消息，就会给该订阅消息的授权次数进行原子加 1。

### 5.5.2.发送订阅消息方式说明

当我们在小程序端累积了某个模板 ID 的授权次数之后，就可以通过云函数来调用 subscribeMessage.send 接口发送订阅消息了。而这个云函数我们可以在小程序端调用，也可以使用云函数来调用云函数，还能使用定时触发器来调用云函数。

- 小程序端发送订阅消息，有些业务需要在用户在小程序内完成了某个操作之后，就需要向用户发送订阅消息，比如打卡、签到、支付、发表成功等，这些业务都依赖于用户的操作，当操作完成之后就可以在回调函数里调用发送订阅消息的云函数；
- 还有一种就是，如果你是小程序的管理员，订阅消息的管理界面也在小程序里，当管理员在小程序端点击定点或群发订阅消息时，也可以调用云函数来发送订阅消息；
- 使用定时触发器发送订阅消息，这时订阅消息就可以周期性、定时发送，不再需要用户/管理员点击就可以结合业务场景发送。

云函数调用 subscribeMessage.send 接口的方式有两种，一种是 HTTPS 调用，还有一种就是云调用，建议使用云调用。调用 subscribeMessage.send 接口时有很多细节需要注意，尤其是 data 格式，必须符合格式要求。

**订阅消息的 data 必须与模板消息一一对应**

比如我们申请到一个**订阅课程开课提醒**的模板，它的格式如下：

```
姓名{{phrase1.DATA}}

课程标题{{thing2.DATA}}

课程内容{{thing3.DATA}}

时间{{date5.DATA}}

课程进度{{character_string6.DATA}}
```

与之相应的 data 的写法如下 phrase1、thing2、thing3、date5、character_string6，这些需要一一对应，参数不能多也不能少，参数后面的数字比如 date5 不能改成 date6，否则会报`"openapi.subscribeMessage.send:fail argument invalid! hint:`的错误，也就是模板里有什么参数，你就只能按部就班写什么参数：

```
data: {

  "phrase1": {

    "value": '李东'

  },

  "thing2": {

    "value": '零基础云开发技术训练营第7课'

  },

  "thing3": {

    "value": '列表渲染与条件渲染'

  },

  "date5": {

    "value": '2019年10月20日 20:00'

  },

  "character_string6": {

    "value": 3

  }

}
```

**订阅消息参数值的内容格式必须要符合要求**

在技术文档里，有一个关于订阅消息参数值的内容格式要求，这个在写订阅消息内容的时候需要严格的一一对应，否则会出现格式错误。

| 参数类别              | 参数说明 | 参数值限制                                          | 说明                                                         |
| --------------------- | -------- | --------------------------------------------------- | ------------------------------------------------------------ |
| thing.DATA            | 事物     | 20个以内字符                                        | 可汉字、数字、字母或符号组合                                 |
| number.DATA           | 数字     | 32位以内数字                                        | 只能数字，可带小数                                           |
| letter.DATA           | 字母     | 32位以内字母                                        | 只能字母                                                     |
| symbol.DATA           | 符号     | 5位以内符号                                         | 只能符号                                                     |
| character_string.DATA | 字符串   | 32位以内数字、字母或符号                            | 可数字、字母或符号组合                                       |
| time.DATA             | 时间     | 24小时制时间格式（支持+年月日）                     | 例如：15:01，或：2019年10月1日 15:01                         |
| date.DATA             | 日期     | 年月日格式（支持+24小时制时间）                     | 例如：2019年10月1日，或：2019年10月1日 15:01                 |
| amount.DATA           | 金额     | 1个币种符号+10位以内纯数字，可带小数，结尾可带“元”  | 可带小数                                                     |
| phone_number.DATA     | 电话     | 17位以内，数字、符号                                | 电话号码，例：+86-0766-66888866                              |
| car_number.DATA       | 车牌     | 8位以内，第一位与最后一位可为汉字，其余为字母或数字 | 车牌号码：粤A8Z888挂                                         |
| name.DATA             | 姓名     | 10个以内纯汉字或20个以内纯字母或符号                | 中文名10个汉字内；纯英文名20个字母内；中文和字母混合按中文名算，10个字内 |
| phrase.DATA           | 汉字     | 5个以内汉字                                         | 5个以内纯汉字，例如：配送中                                  |

下面列举一些在使用过程中容易犯的错误：

- 可能已有的模板消息的格式和你想要的不一致，比如你希望发送的消息是用户的昵称，而不是`姓名{{phrase1.DATA}}`,因为姓名只能是中文，且必须 5 个字以内，那你就没法擅自改动，只能去申请或复用其他的模板 ID；
- 每个格式对字符串的长度和类型都有严格的要求，比如 thing，要求必须是 20 个以内的字符，不能超过 20 个字符；有些只能是数字或字母，就不能是其他格式

### 5.5.3.使用云调用发送订阅消息

在前面我们说过，在小程序端**哪个用户**点击授权就只会给**哪个用户**增加授权次数，而借助于云函数发送订阅消息则用户可以**给任何人**发送订阅消息，发给哪个人就需要哪个人有授权次数，就会减少哪个人的授权次数，这一点要注意区分。

#### 1、发送单条订阅消息

新建一个云函数比如 subscribeMessage，然后再在 config.json 的添加 subscribeMessage.send 权限，使用云函数增量上传更新这个配置文件。

```json
{
  "permissions": {
    "openapi": [
      "subscribeMessage.send"
    ]
  }
}
```

然后再在 index.js 里输入以下代码，注意这里的 openid，是用户自己的，这种适用于用户在小程序端完成某个业务操作之后，就给用户自己发订阅消息；当然这里的 openid 可以是其他累积了授权次数的用户的，也就是当我们在小程序端调用该云函数就能给其他人发订阅消息了，这主要适用于管理员：

```javascript
const cloud = require("wx-server-sdk");

cloud.init({
  env: cloud.DYNAMIC_CURRENT_ENV,
});

exports.main = async (event, context) => {
  const { OPENID } = cloud.getWXContext();

  try {
    const result = await cloud.openapi.subscribeMessage.send({
      touser: "oUL-m5FuRmuVmxvbYOGuXbuEDsn8",

      page: "index",

      templateId: "qY7MhvZOnL0QsRzK_C7FFsXTT7Kz0-knXMwkF1ewY44",

      data: {
        phrase1: {
          value: "小明",
        },

        thing2: {
          value: "零基础云开发技术训练营第7课",
        },

        thing3: {
          value: "列表渲染与条件渲染",
        },

        date5: {
          value: "2019年10月20日 20:00",
        },

        character_string6: {
          value: 3,
        },
      },
    });

    return result;
  } catch (err) {
    console.log(err);

    return err;
  }
};
```

#### 2、批量发送订阅消息

由于 subscribeMessage.send 的参数 templateId 和 touser 都是字符串，因此执行一次 subscribeMessage.send 只能给一个用户发送一条订阅消息，那要给更多用户比如 1000 人以内（云函数一次可以获取到 1000 条数据）发订阅消息，则需要结合数据库的查询数据库内所有有授权次数的用户然后循环执行来发消息，并在发完之后使用 inc 自减来减去授权次数。

由于我们把用户授权的所有订阅消息内嵌到 templs 这个数组里，而要发送的订阅消息的内容则来自 templs 数组里符合条件的对象，这里涉及到相对比较复杂的数组的处理，因此数据分析处理神器聚合就派上用场了（当然我们也可以使用普通查询，普通查询得到的是记录列表，再使用一些数组方法如 filter、map 等取出列表里的 templs 嵌套的对象列表）。

```javascript
const cloud = require("wx-server-sdk");

cloud.init({
  env: cloud.DYNAMIC_CURRENT_ENV,
});

const db = cloud.database();

const _ = db.command;

const $ = db.command.aggregate;

exports.main = async (event, context) => {
  const templateId = "qY7MhvZOnL0QsRzK_C7FFsXTT7Kz0-knXMwkF1ewY44";

  try {
    const messages = (
      await db
        .collection("messages")
        .aggregate()

        .match({
          //使用match匹配查询

          "templs.templateId": templateId, //注意这里templs.templateId的写法

          done: false,

          status: 1,
        })

        .project({
          _id: 0,

          templs: $.filter({
            //从嵌套的templs数组里取出模板ID满足条件的对象

            input: "$templs",

            as: "item",

            cond: $.eq(["$$item.templateId", templateId]),
          }),
        })

        .project({
          message: $.arrayElemAt(["$templs", 0]), //符号条件的是只有1个对象的数组，取出这个对象
        })

        .end()
    ).list; //使用聚合查询到的是一个list对象

    const tasks = [];

    for (let item in messages) {
      const promise = cloud.openapi.subscribeMessage.send({
        touser: item.message._openid,

        page: "index",

        templateId: item.message.templateId,

        data: item.message.data,
      });

      tasks.push(promise);
    }

    return (await Promise.all(tasks)).reduce((acc, cur) => {
      return {
        data: acc.data.concat(cur.data),

        errMsg: acc.errMsg,
      };
    });
  } catch (err) {
    console.log(err);

    return err;
  }
};
```

> 特别注意的是，不要把查询数据库的语句放到循环里面，也就是我们可以一次性取出 1000 条需要发订阅消息的用户，然后再结合 map 和 Promise.all 方法给这 1000 个用户发送订阅消息，然后再一次性给所有这 1000 条数据进行原子自增，不能一条一条处理，否则会造成数据库性能的极大浪费以及超出最大连接数，而且也会导致云函数在最高 60s 的生命周期里也发送不了几百条订阅消息。

### 5.5.4.使用定时触发器发订阅消息

但是当要发送订阅消息的用户有几十万几百万，那应该怎么处理呢？如果全部让云函数来执行，即使将云函数的执行超时时间修改为 60s，也应该会超时，这时候我们可以结合定时器来发送订阅消息。

使用定时触发器来发送订阅消息，也就是在小程序的云开发服务端，用定时触发器调用订阅消息的云调用接口 openapi.subscribeMessage.send。当我们每天要给数十万人定时发送订阅消息时，这时候定时触发器就不仅仅需要比如每天早上 9 点触发，而且还需要在 9 点之后能够每隔一段时间比如 40s,就来执行一次云函数以便给数十万用户发送订阅消息。

这时候 Cron 表达式可以这样写，意思是每天早上 9 点到 11 点每隔 40s 执行一次云函数：

```
0/40 * 9-11 * * * *
```

当然这里的周期设置可以结合云函数实际执行的时间来定，要充分考虑到云函数的超时时间。

> 云调用还支持组合模板并添加至帐号下的个人模板库的接口`subscribeMessage.addTemplate`、删除帐号下的个人模板`subscribeMessage.deleteTemplate`、获取小程序账号的类目`subscribeMessage.getCategory`、获取当前帐号下的个人模板列表`subscribeMessage.getTemplateList`等等接口，这里就不一一介绍啦。



# 6.flex布局

## 6.1.flex-direction

在给view设置属性display: flex;之后，view的布局方式就会变为flex模式，此外还需要设置其flex-direction控制布局方向,flex-direction有4个值：

- row：从左到右的水平方向为主轴
- row-reverse：从右到左的水平方向为主轴
- column：从上到下的垂直方向为主轴
- column-reverse：从下到上的垂直方向为主轴

### 6.1.1.flex-direction: row

```html
<view class='flex'>
    <view class='flex-item' style='background:red;'>1</view>
    <view class='flex-item' style='background:blue;'>2</view>
    <view class='flex-item' style='background:yellow;'>3</view>
</view>
```

```css
.flex {
  display: flex;
  flex-direction: row;
  background: lightgray
}
.flex-item {
  width: 60px;
}
```

## 6.2.justify-content

设置完view的布局方向之后，想要控制内容的对齐方式，需要设置justify-content属性，该属性值有：

- flex-start：主轴起点对齐(默认值)。
- flex-end：主轴终点对齐。
- center：在主轴中居中对齐。
- space-between：两端对齐，除了两端的子元素分别靠向两端的容器之外，其他子元素之间的间隔都相等。
- space-around：每个子元素之间的距离相等，两端的子元素距离容器的距离也和其它子元素之间的距离相同。

Eg: **flex-start**

```html
<view class='flex'>
    <view class='flex-item' style='background:red;'>1</view>
    <view class='flex-item' style='background:blue;'>2</view>
    <view class='flex-item' style='background:yellow;'>3</view>
</view>
```

```css
.flex {
  display: flex;
  flex-direction: row;
  justify-content: flex-start;
  background: lightgray
}

.flex-item {
  width: 60px;
}
```

## 6.3.align-items

`align-items`属性值有：

- stretch 填充整个容器(默认值)
- flex-start 起点对齐
- flex-end 终点对齐
- center 居中对齐
- baseline 以子元素的第一行文字对齐

Eg: **baseline**

```html
<view class='flex'>
    <view class='flex-item' style='background:red; height:50px;'>1</view>
    <view class='flex-item' style='background:blue; height:70px;'>2</view>
    <view class='flex-item' style='background:yellow;height:90px;'>3</view>
</view>
```

```css
.flex {
  display: flex;
  flex-direction: row;
  background: lightgray;
  justify-content: space-around;
  align-items: baseline;
  height: 100px;
}

.flex-item {
  width: 60px;
}
```

## 6.4.align-self

子 View 还有个属性 align-self，可以覆盖父元素的 align-items 属性，它有6个值可选：auto | flex-start | flex-end | center | baseline | stretch （auto 为继承父元素 align-items 属性，其他和 align-items 一致）

此外还有 flex-wrap 属性，用于控制子 View 是否换行，有3个值可选：

- nowrap：不换行（默认）
- wrap：换行
- wrap-reverse：换行，第一行在最下面

## 6.5.order

子 View 有个 order 属性，可以控制子元素的排列顺序，默认为0。
